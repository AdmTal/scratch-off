<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scratch-Off Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 40px 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 40px;
    }

    h1 {
      color: white;
      font-size: 3rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }

    .tagline {
      color: rgba(255,255,255,0.9);
      font-size: 1.25rem;
    }

    .card {
      background: white;
      border-radius: 16px;
      padding: 30px;
      margin-bottom: 24px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }

    .card h2 {
      color: #333;
      margin-bottom: 15px;
      font-size: 1.5rem;
    }

    .card p {
      color: #666;
      line-height: 1.7;
      margin-bottom: 15px;
    }

    .features {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .feature {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
    }

    .feature-icon {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    .feature h3 {
      color: #333;
      font-size: 1rem;
      margin-bottom: 8px;
    }

    .feature p {
      color: #888;
      font-size: 0.9rem;
      margin: 0;
    }

    .cta-button {
      display: inline-block;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 40px;
      border-radius: 30px;
      text-decoration: none;
      font-weight: 600;
      font-size: 1.1rem;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .cta-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    .code-block {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 20px;
      border-radius: 8px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.9rem;
      overflow-x: auto;
    }

    footer {
      text-align: center;
      color: rgba(255,255,255,0.7);
      margin-top: 40px;
      padding: 20px;
    }

    footer a {
      color: white;
    }

    .hero-image {
      width: 100%;
      max-width: 400px;
      height: 200px;
      background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
      border-radius: 12px;
      margin: 20px auto;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.5rem;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Scratch-Off</h1>
      <p class="tagline">covers your site in lottery ticket gunk. scratch to reveal.</p>
    </header>

    <div class="card">
      <h2>you're looking at it</h2>
      <p>this whole page is covered. scratch it off with your mouse. or finger. whatever.</p>
      <p>get ~90% and it fades away on its own. satisfying.</p>
      <div class="hero-image">scratch here dummy</div>
    </div>

    <div class="card">
      <h2>what you get</h2>
      <div class="features">
        <div class="feature">
          <div class="feature-icon">ðŸŽ¨</div>
          <h3>looks real</h3>
          <p>actually looks like a lottery ticket</p>
        </div>
        <div class="feature">
          <div class="feature-icon">ðŸ“±</div>
          <h3>works on phones</h3>
          <p>touch works fine</p>
        </div>
        <div class="feature">
          <div class="feature-icon">ðŸ”Š</div>
          <h3>sounds</h3>
          <p>that scratchy noise. you know the one.</p>
        </div>
        <div class="feature">
          <div class="feature-icon">âœ¨</div>
          <h3>particles</h3>
          <p>little paint flakes fall off</p>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>installation</h2>
      <p>one script tag. thats it.</p>
      <div class="code-block">
        &lt;script src="https://scratchy-lotto.com/scratch-off.iife.js"&gt;&lt;/script&gt;
      </div>
    </div>

    <footer>
      <p>typescript + canvas. nothing fancy.</p>
      <p><a href="https://github.com">github</a></p>
    </footer>
  </div>

  <script>
/**
 * Scratch-Off Library
 * Turns any website into a scratch-off lottery ticket experience
 */

class ScratchOff {
  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.scratchCanvas = document.createElement('canvas');
    this.scratchCtx = this.scratchCanvas.getContext('2d');
    this.particleCanvas = document.createElement('canvas');
    this.particleCtx = this.particleCanvas.getContext('2d');
    this.particles = [];
    this.isMouseScratching = false;
    this.mouseLastX = 0;
    this.mouseLastY = 0;
    this.activeTouches = new Map();
    this.scratchRadius = 30;
    this.totalPixels = 0;
    this.scratchedPixels = 0;
    this.fadeThreshold = 0.90;
    this.isFading = false;
    this.audioContext = null;
    this.audioInitialized = false;
    this.animationId = null;
    this.shapes = [];
    this.baseColor = '#C0C0C0';
    this.accentColors = ['#A8A8A8', '#B8B8B8', '#D0D0D0', '#BEBEBE'];
    this.lastScratchDirection = null;
    this.scratchDirectionChangeCount = 0;
    this.hasStartedScratching = false;
    this.progressMilestonesReached = new Set();
    this.sessionStartTime = 0;
    this.scratchCount = 0;
    this.deviceType = 'mouse';

    this.init();
  }

  init() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.setup());
    } else {
      setTimeout(() => this.setup(), 100);
    }
  }

  setup() {
    const width = window.innerWidth;
    const height = window.innerHeight;

    this.canvas.width = width;
    this.canvas.height = height;
    this.canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      cursor: crosshair;
      touch-action: none;
    `;

    this.scratchCanvas.width = width;
    this.scratchCanvas.height = height;

    this.particleCanvas.width = width;
    this.particleCanvas.height = height;
    this.particleCanvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000000;
      pointer-events: none;
    `;

    this.totalPixels = width * height;

    this.detectElements();
    this.drawScratchLayer();

    document.body.appendChild(this.canvas);
    document.body.appendChild(this.particleCanvas);

    document.body.style.overflow = 'hidden';

    this.bindEvents();
    this.initAudioOnInteraction();
    this.animate();
  }

  initAudioOnInteraction() {
    document.addEventListener('mousedown', this.ensureAudioInitialized.bind(this), { capture: true });
    document.addEventListener('touchstart', this.ensureAudioInitialized.bind(this), { capture: true });
  }

  ensureAudioInitialized() {
    if (this.audioInitialized) return;
    this.audioInitialized = true;

    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (this.audioContext.state === 'suspended') {
        this.audioContext.resume();
      }
    } catch (e) {
      // Audio not supported
    }
  }

  detectElements() {
    const elements = document.body.querySelectorAll('*');
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    elements.forEach((el) => {
      if (el === this.canvas) return;

      const rect = el.getBoundingClientRect();

      if (
        rect.width > 0 &&
        rect.height > 0 &&
        rect.top < viewportHeight &&
        rect.bottom > 0 &&
        rect.left < viewportWidth &&
        rect.right > 0
      ) {
        const tagName = el.tagName.toLowerCase();
        const computedStyle = window.getComputedStyle(el);

        if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden') {
          return;
        }

        let color = this.getShapeColor(tagName, computedStyle);

        const borderTopWidth = parseFloat(computedStyle.borderTopWidth) || 0;
        const borderRightWidth = parseFloat(computedStyle.borderRightWidth) || 0;
        const borderBottomWidth = parseFloat(computedStyle.borderBottomWidth) || 0;
        const borderLeftWidth = parseFloat(computedStyle.borderLeftWidth) || 0;
        const hasBorder = (borderTopWidth + borderRightWidth + borderBottomWidth + borderLeftWidth) > 0;
        const borderColor = computedStyle.borderColor || '#888888';

        let hasText = false;
        let textLength = 0;
        let textLines = [];
        let fontSize = parseFloat(computedStyle.fontSize) || 16;
        let lineHeight = parseFloat(computedStyle.lineHeight) || fontSize * 1.2;

        const textTags = ['p', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'a', 'button', 'label', 'td', 'th', 'strong', 'em', 'code', 'pre'];
        if (textTags.includes(tagName)) {
          const textNodes = Array.from(el.childNodes)
            .filter(node => node.nodeType === Node.TEXT_NODE && node.textContent?.trim());

          if (textNodes.length > 0) {
            hasText = true;
            textLength = textNodes.map(n => n.textContent?.trim() || '').join('').length;
            textLines = this.getTextLineRects(el, textNodes);
          }
        }

        if (this.isSignificantElement(tagName, rect)) {
          this.shapes.push({
            x: Math.max(0, rect.left),
            y: Math.max(0, rect.top),
            width: Math.min(rect.width, viewportWidth - rect.left),
            height: Math.min(rect.height, viewportHeight - rect.top),
            color,
            type: tagName,
            hasBorder,
            borderColor,
            hasText,
            textLength,
            textLines,
            fontSize,
            lineHeight
          });
        }
      }
    });

    this.shapes.sort((a, b) => (b.width * b.height) - (a.width * a.height));
  }

  isSignificantElement(tagName, rect) {
    const significantTags = [
      'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
      'p', 'div', 'section', 'article', 'header', 'footer', 'nav', 'main', 'aside',
      'img', 'video', 'canvas', 'svg',
      'button', 'a', 'input', 'textarea', 'select',
      'ul', 'ol', 'li', 'table', 'form',
      'span', 'strong', 'em', 'code', 'pre'
    ];

    if (rect.width < 10 || rect.height < 10) return false;

    return significantTags.includes(tagName);
  }

  getTextLineRects(element, textNodes) {
    const lines = [];
    const range = document.createRange();

    textNodes.forEach(textNode => {
      if (!textNode.textContent) return;

      range.selectNodeContents(textNode);
      const rects = range.getClientRects();

      for (let i = 0; i < rects.length; i++) {
        const rect = rects[i];
        if (rect.width > 5 && rect.height > 5) {
          const existingLine = lines.find(
            line => Math.abs(line.y - rect.top) < rect.height * 0.5
          );

          if (existingLine) {
            const minX = Math.min(existingLine.x, rect.left);
            const maxX = Math.max(existingLine.x + existingLine.width, rect.right);
            existingLine.x = minX;
            existingLine.width = maxX - minX;
          } else {
            lines.push({
              x: rect.left,
              y: rect.top,
              width: rect.width,
              height: rect.height
            });
          }
        }
      }
    });

    lines.sort((a, b) => a.y - b.y);
    return lines;
  }

  getContrastColor(hexColor) {
    const hex = hexColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);

    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

    return luminance > 0.5 ? 'rgba(40, 40, 40, 0.7)' : 'rgba(230, 230, 230, 0.7)';
  }

  formatElementLabel(tagName) {
    return `<${tagName} />`;
  }

  getShapeColor(tagName, style) {
    const headingColors = {
      'h1': '#888888',
      'h2': '#909090',
      'h3': '#989898',
      'h4': '#A0A0A0',
      'h5': '#A8A8A8',
      'h6': '#B0B0B0'
    };

    if (headingColors[tagName]) {
      return headingColors[tagName];
    }

    if (['img', 'video', 'svg', 'canvas'].includes(tagName)) {
      return '#707070';
    }

    if (['button', 'a', 'input', 'select', 'textarea'].includes(tagName)) {
      return '#858585';
    }

    if (['p', 'span', 'li'].includes(tagName)) {
      return '#A5A5A5';
    }

    return this.accentColors[Math.floor(Math.random() * this.accentColors.length)];
  }

  drawScratchLayer() {
    const width = this.canvas.width;
    const height = this.canvas.height;

    this.ctx.fillStyle = this.baseColor;
    this.ctx.fillRect(0, 0, width, height);

    this.shapes.forEach(shape => {
      this.ctx.fillStyle = shape.color;
      const radius = Math.min(4, shape.width / 4, shape.height / 4);
      this.roundRect(shape.x, shape.y, shape.width, shape.height, radius);
    });

    this.addTexture();
    this.drawElementLabels();
    this.drawBorderOutlines();
    this.drawTextPlaceholders();

    this.scratchCtx.fillStyle = '#FFFFFF';
    this.scratchCtx.fillRect(0, 0, width, height);
  }

  drawElementLabels() {
    this.ctx.textAlign = 'center';
    this.ctx.textBaseline = 'middle';

    this.shapes.forEach(shape => {
      const label = this.formatElementLabel(shape.type);
      const textColor = this.getContrastColor(shape.color);

      const maxWidth = shape.width * 0.8;
      const maxHeight = shape.height * 0.4;

      let fontSize = Math.min(maxHeight, 24);
      fontSize = Math.max(fontSize, 8);

      this.ctx.font = `${fontSize}px "SF Mono", "Monaco", "Inconsolata", "Roboto Mono", monospace`;

      let textWidth = this.ctx.measureText(label).width;
      while (textWidth > maxWidth && fontSize > 8) {
        fontSize -= 1;
        this.ctx.font = `${fontSize}px "SF Mono", "Monaco", "Inconsolata", "Roboto Mono", monospace`;
        textWidth = this.ctx.measureText(label).width;
      }

      if (fontSize >= 8 && shape.width >= 30 && shape.height >= 16) {
        const centerX = shape.x + shape.width / 2;
        const centerY = shape.y + shape.height / 2;

        this.ctx.fillStyle = textColor;
        this.ctx.fillText(label, centerX, centerY);
      }
    });
  }

  drawBorderOutlines() {
    this.shapes.forEach(shape => {
      if (!shape.hasBorder) return;

      const padding = 2;
      const x = shape.x + padding;
      const y = shape.y + padding;
      const width = shape.width - padding * 2;
      const height = shape.height - padding * 2;

      if (width <= 0 || height <= 0) return;

      this.ctx.save();
      this.ctx.strokeStyle = 'rgba(60, 60, 60, 0.6)';
      this.ctx.lineWidth = 2;
      this.ctx.setLineDash([6, 4]);

      const radius = Math.min(4, width / 4, height / 4);
      this.ctx.beginPath();
      this.ctx.moveTo(x + radius, y);
      this.ctx.lineTo(x + width - radius, y);
      this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      this.ctx.lineTo(x + width, y + height - radius);
      this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      this.ctx.lineTo(x + radius, y + height);
      this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      this.ctx.lineTo(x, y + radius);
      this.ctx.quadraticCurveTo(x, y, x + radius, y);
      this.ctx.closePath();
      this.ctx.stroke();

      this.ctx.restore();
    });
  }

  drawTextPlaceholders() {
    this.ctx.save();

    this.shapes.forEach(shape => {
      if (!shape.hasText || shape.textLines.length === 0) return;

      shape.textLines.forEach(line => {
        this.ctx.fillStyle = 'rgba(40, 40, 40, 0.6)';

        const barHeight = line.height * 0.75;
        const yOffset = (line.height - barHeight) / 2;

        const radius = Math.min(3, barHeight / 4);
        const x = line.x;
        const y = line.y + yOffset;
        const width = line.width;
        const height = barHeight;

        this.ctx.beginPath();
        this.ctx.moveTo(x + radius, y);
        this.ctx.lineTo(x + width - radius, y);
        this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.ctx.lineTo(x + width, y + height - radius);
        this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.ctx.lineTo(x + radius, y + height);
        this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.ctx.lineTo(x, y + radius);
        this.ctx.quadraticCurveTo(x, y, x + radius, y);
        this.ctx.closePath();
        this.ctx.fill();
      });
    });

    this.ctx.restore();
  }

  roundRect(x, y, width, height, radius) {
    this.ctx.beginPath();
    this.ctx.moveTo(x + radius, y);
    this.ctx.lineTo(x + width - radius, y);
    this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    this.ctx.lineTo(x + width, y + height - radius);
    this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    this.ctx.lineTo(x + radius, y + height);
    this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    this.ctx.lineTo(x, y + radius);
    this.ctx.quadraticCurveTo(x, y, x + radius, y);
    this.ctx.closePath();
    this.ctx.fill();
  }

  addTexture() {
    const width = this.canvas.width;
    const height = this.canvas.height;
    const imageData = this.ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
      const noise = (Math.random() - 0.5) * 30;
      data[i] = Math.max(0, Math.min(255, data[i] + noise));
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
    }

    this.ctx.putImageData(imageData, 0, 0);

    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    this.ctx.lineWidth = 1;
    for (let y = 0; y < height; y += 3) {
      if (Math.random() > 0.5) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, y);
        this.ctx.lineTo(width, y);
        this.ctx.stroke();
      }
    }

    for (let i = 0; i < 500; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const size = Math.random() * 2;
      this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5})`;
      this.ctx.beginPath();
      this.ctx.arc(x, y, size, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }

  bindEvents() {
    this.canvas.addEventListener('mousedown', this.handleStart.bind(this));
    this.canvas.addEventListener('mousemove', this.handleMove.bind(this));
    this.canvas.addEventListener('mouseup', this.handleEnd.bind(this));
    this.canvas.addEventListener('mouseleave', this.handleEnd.bind(this));

    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
    this.canvas.addEventListener('touchcancel', this.handleTouchEnd.bind(this), { passive: false });
  }

  handleStart(e) {
    this.isMouseScratching = true;
    this.mouseLastX = e.clientX;
    this.mouseLastY = e.clientY;
    this.scratch(e.clientX, e.clientY, this.mouseLastX, this.mouseLastY);
    this.mouseLastX = e.clientX;
    this.mouseLastY = e.clientY;
  }

  handleMove(e) {
    if (!this.isMouseScratching) return;
    this.scratch(e.clientX, e.clientY, this.mouseLastX, this.mouseLastY);
    this.mouseLastX = e.clientX;
    this.mouseLastY = e.clientY;
  }

  handleEnd() {
    this.isMouseScratching = false;
  }

  handleTouchStart(e) {
    e.preventDefault();
    this.deviceType = 'touch';
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      const touchState = {
        lastX: touch.clientX,
        lastY: touch.clientY
      };
      this.activeTouches.set(touch.identifier, touchState);
      this.scratch(touch.clientX, touch.clientY, touchState.lastX, touchState.lastY);
    }
  }

  handleTouchMove(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      const touchState = this.activeTouches.get(touch.identifier);
      if (touchState) {
        this.scratch(touch.clientX, touch.clientY, touchState.lastX, touchState.lastY);
        touchState.lastX = touch.clientX;
        touchState.lastY = touch.clientY;
      }
    }
  }

  handleTouchEnd(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      this.activeTouches.delete(touch.identifier);
    }
  }

  hasPaintAt(x, y) {
    const sampleSize = Math.max(4, Math.floor(this.scratchRadius / 3));
    const startX = Math.max(0, Math.floor(x - sampleSize / 2));
    const startY = Math.max(0, Math.floor(y - sampleSize / 2));
    const width = Math.min(sampleSize, this.canvas.width - startX);
    const height = Math.min(sampleSize, this.canvas.height - startY);

    if (width <= 0 || height <= 0) return false;

    try {
      const imageData = this.ctx.getImageData(startX, startY, width, height);
      const data = imageData.data;

      for (let i = 3; i < data.length; i += 4) {
        if (data[i] > 0) {
          return true;
        }
      }
    } catch (e) {
      return true;
    }

    return false;
  }

  scratch(x, y, lastX, lastY) {
    if (this.isFading) return;

    if (!this.hasStartedScratching) {
      this.hasStartedScratching = true;
      this.sessionStartTime = Date.now();
    }

    this.scratchCount++;

    const hasPaint = this.hasPaintAt(x, y);

    const dx = x - lastX;
    const dy = y - lastY;
    let currentDirection;

    if (Math.abs(dy) > Math.abs(dx)) {
      currentDirection = dy > 0 ? 'down' : 'up';
    } else {
      currentDirection = dx > 0 ? 'right' : 'left';
    }

    const directionChanged = this.lastScratchDirection !== null &&
      this.lastScratchDirection !== currentDirection;
    if (directionChanged) {
      this.scratchDirectionChangeCount++;
    }
    this.lastScratchDirection = currentDirection;

    if (hasPaint) {
      this.playScratchSound(directionChanged);
      this.createParticles(x, y);
    }

    this.ctx.globalCompositeOperation = 'destination-out';
    this.drawIrregularLine(this.ctx, lastX, lastY, x, y);
    this.drawIrregularScratch(this.ctx, x, y);
    this.ctx.globalCompositeOperation = 'source-over';

    this.scratchCtx.fillStyle = '#000000';
    this.drawIrregularLine(this.scratchCtx, lastX, lastY, x, y);
    this.drawIrregularScratch(this.scratchCtx, x, y);

    if (Math.random() < 0.1) {
      this.checkProgress();
    }
  }

  drawIrregularScratch(ctx, x, y) {
    const points = 8 + Math.floor(Math.random() * 5);
    const angleStep = (Math.PI * 2) / points;
    const baseAngle = Math.random() * Math.PI * 2;

    ctx.beginPath();
    for (let i = 0; i <= points; i++) {
      const angle = baseAngle + i * angleStep;
      const radiusVariation = 0.7 + Math.random() * 0.3;
      const r = this.scratchRadius * radiusVariation;
      const px = x + Math.cos(angle) * r;
      const py = y + Math.sin(angle) * r;

      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
    ctx.closePath();
    ctx.fill();
  }

  drawIrregularLine(ctx, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);

    if (length < 1) return;

    const nx = -dy / length;
    const ny = dx / length;

    const segments = Math.max(4, Math.floor(length / 8));
    const points = [];

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const baseX = x1 + dx * t;
      const baseY = y1 + dy * t;
      const widthVariation = 0.8 + Math.random() * 0.3;
      const offset = this.scratchRadius * widthVariation;
      points.push({
        x: baseX + nx * offset,
        y: baseY + ny * offset
      });
    }

    for (let i = segments; i >= 0; i--) {
      const t = i / segments;
      const baseX = x1 + dx * t;
      const baseY = y1 + dy * t;
      const widthVariation = 0.8 + Math.random() * 0.3;
      const offset = this.scratchRadius * widthVariation;
      points.push({
        x: baseX - nx * offset,
        y: baseY - ny * offset
      });
    }

    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.closePath();
    ctx.fill();
  }

  createParticles(x, y) {
    const particleCount = 3 + Math.floor(Math.random() * 5);

    for (let i = 0; i < particleCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 4;
      const colors = ['#C0C0C0', '#A8A8A8', '#B8B8B8', '#D0D0D0', '#909090'];

      this.particles.push({
        x: x + (Math.random() - 0.5) * this.scratchRadius,
        y: y + (Math.random() - 0.5) * this.scratchRadius,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed + 5,
        size: 2 + Math.random() * 4,
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.3,
        life: 1,
        maxLife: 30 + Math.random() * 30,
        shapeOffsets: [
          Math.random(),
          Math.random(),
          Math.random(),
          Math.random(),
          Math.random(),
          Math.random()
        ]
      });
    }
  }

  updateParticles() {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];

      p.vy += 0.4;
      p.vx *= 0.98;
      p.vy *= 0.98;

      p.vx += (Math.random() - 0.5) * 0.15;

      p.x += p.vx;
      p.y += p.vy;
      p.rotation += p.rotationSpeed;
      p.life++;

      if (p.y > this.canvas.height + 20 || p.life > p.maxLife) {
        this.particles.splice(i, 1);
      }
    }
  }

  drawParticles() {
    this.particleCtx.clearRect(0, 0, this.particleCanvas.width, this.particleCanvas.height);

    this.particles.forEach(p => {
      const alpha = 1 - (p.life / p.maxLife);
      this.particleCtx.save();
      this.particleCtx.translate(p.x, p.y);
      this.particleCtx.rotate(p.rotation);
      this.particleCtx.fillStyle = p.color;
      this.particleCtx.globalAlpha = alpha;

      const jag = p.size * 0.3;
      const o = p.shapeOffsets;
      this.particleCtx.beginPath();
      this.particleCtx.moveTo(-p.size / 2 + o[0] * jag, -p.size / 3);
      this.particleCtx.lineTo(-p.size / 4, -p.size / 2 + o[1] * jag);
      this.particleCtx.lineTo(p.size / 4, -p.size / 2 + o[2] * jag);
      this.particleCtx.lineTo(p.size / 2 + o[3] * jag, -p.size / 4);
      this.particleCtx.lineTo(p.size / 2, p.size / 4 + o[4] * jag);
      this.particleCtx.lineTo(p.size / 4, p.size / 2);
      this.particleCtx.lineTo(-p.size / 4, p.size / 2 + o[5] * jag);
      this.particleCtx.lineTo(-p.size / 2, p.size / 4);
      this.particleCtx.closePath();
      this.particleCtx.fill();

      this.particleCtx.restore();
    });
  }

  playScratchSound(directionChanged = false) {
    if (!this.audioContext) {
      return;
    }

    const duration = 0.02 + Math.random() * 0.015;
    const sampleRate = this.audioContext.sampleRate;
    const bufferSize = Math.floor(sampleRate * duration);
    const buffer = this.audioContext.createBuffer(1, bufferSize, sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
      const position = i / bufferSize;
      const envelope = Math.pow(Math.sin(position * Math.PI), 1.5);
      data[i] = (Math.random() * 2 - 1) * 0.15 * envelope;
    }

    const source = this.audioContext.createBufferSource();
    source.buffer = buffer;

    const baseFreq = directionChanged ? 1800 : 1200;
    const freqVariation = directionChanged ? 600 : 400;

    const filter = this.audioContext.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = baseFreq + Math.random() * freqVariation;
    filter.Q.value = directionChanged ? 1.2 : 0.8;

    const lowpass = this.audioContext.createBiquadFilter();
    lowpass.type = 'lowpass';
    lowpass.frequency.value = 2500;
    lowpass.Q.value = 0.5;

    const gainNode = this.audioContext.createGain();
    gainNode.gain.value = directionChanged ? 0.04 : 0.025;

    source.connect(filter);
    filter.connect(lowpass);
    lowpass.connect(gainNode);
    gainNode.connect(this.audioContext.destination);

    source.start();
  }

  checkProgress() {
    const imageData = this.scratchCtx.getImageData(
      0, 0,
      this.scratchCanvas.width,
      this.scratchCanvas.height
    );
    const data = imageData.data;

    let scratched = 0;
    for (let i = 0; i < data.length; i += 400) {
      if (data[i] === 0) {
        scratched++;
      }
    }

    const sampleTotal = Math.floor(data.length / 400);
    const progress = scratched / sampleTotal;

    const milestones = [25, 50, 75];
    for (const milestone of milestones) {
      const threshold = milestone / 100;
      if (progress >= threshold && !this.progressMilestonesReached.has(milestone)) {
        this.progressMilestonesReached.add(milestone);
      }
    }

    if (progress >= this.fadeThreshold && !this.isFading) {
      this.fadeOut();
    }
  }

  fadeOut() {
    this.isFading = true;

    this.canvas.style.transition = 'opacity 0.8s ease-out';
    this.canvas.style.opacity = '0';
    this.particleCanvas.style.transition = 'opacity 0.8s ease-out';
    this.particleCanvas.style.opacity = '0';

    setTimeout(() => {
      this.cleanup();
    }, 800);
  }

  cleanup() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }

    if (this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }

    if (this.particleCanvas.parentNode) {
      this.particleCanvas.parentNode.removeChild(this.particleCanvas);
    }

    document.body.style.overflow = '';

    if (this.audioContext) {
      this.audioContext.close();
    }
  }

  animate() {
    this.updateParticles();
    this.drawParticles();

    this.animationId = requestAnimationFrame(() => this.animate());
  }
}

// Auto-initialize when script loads
new ScratchOff();
  </script>
</body>
</html>
